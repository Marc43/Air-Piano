<LINK REL="stylesheet" HREF="../static/styles.css">
<HTML>
<HEAD>
<TITLE>Studio::Bus::getChannelGroup</TITLE>
</HEAD>
<BODY TOPMARGIN="0" class="api_reference">
<p class="header">Firelight Technologies FMOD Studio API</p>
<H1>Studio::Bus::getChannelGroup</H1>
<P>
<p>Retrieves the Low Level ChannelGroup used by the bus.</p>
</P>
<h3>C++ Syntax</h3>
<PRE class=syntax><CODE>FMOD_RESULT Studio::Bus::getChannelGroup(
  FMOD::ChannelGroup **<I>group</I>
);
</CODE></PRE>
<h3>C Syntax</h3>
<PRE class=syntax><CODE>FMOD_RESULT FMOD_Studio_Bus_GetChannelGroup(
  FMOD_STUDIO_BUS *<I>bus</I>,
  FMOD_CHANNELGROUP **<I>group</I>
);
</CODE></PRE>
<h3>C# Syntax</h3>
<PRE class=syntax><CODE>RESULT Studio.Bus.getChannelGroup(
  out FMOD.ChannelGroup <i>group</i>
);
</CODE></PRE>
<h2>Parameters</h2>
<dl>
<dt>group</dt>
<dd>Address of a variable to receive a pointer to the Low Level ChannelGroup.</dd>
</dl>
<h2>Return Values</h2><P>
If the function succeeds then the return value is <A HREF="FMOD_RESULT.html">FMOD_OK</A>.<BR>
If the function fails then the return value will be one of the values defined in the <A HREF="FMOD_RESULT.html">FMOD_RESULT</A> enumeration.<BR>
</P>
<h2>Remarks</h2><P>
<p>The ChannelGroup is created and destroyed on demand. This means it only exists if at least one event
instance routes into the bus. If it doesn't exist, this function will return <A HREF="FMOD_RESULT.html">FMOD_ERR_STUDIO_NOT_LOADED</A>.</p>

<p>You can force the ChannelGroup to be created by calling <A HREF="FMOD_Studio_Bus_LockChannelGroup.html">Studio::Bus::lockChannelGroup</A>.</p>
</P>
<h2>See Also</h2>
<UL type=disc>
<LI><A HREF="FMOD_Studio_Bus_LockChannelGroup.html">Studio::Bus::lockChannelGroup</A></LI>
<LI><A HREF="FMOD_Studio_Bus_UnlockChannelGroup.html">Studio::Bus::unlockChannelGroup</A></LI>
</UL>
<BR><BR><BR>
<P align=center><font size=-2>Version 1.09.01 Built on Feb 9, 2017</font></P>
<BR>
</HTML>
